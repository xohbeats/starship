<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Galactic Defender</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000; /* Black background for space */
            font-family: 'Inter', sans-serif; /* Using Inter font */
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
            background-color: #000; /* Ensure canvas background is black */
            border-radius: 10px; /* Rounded corners for canvas */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Glowing effect */
            width: 100%; /* Fluid width */
            height: 100%; /* Fluid height */
            max-width: 900px; /* Max width for larger screens */
            max-height: 700px; /* Max height for larger screens */
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #scoreboard {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff; /* Cyan color for scoreboard */
            text-shadow: 0 0 5px #00ffff;
            z-index: 2;
        }
        #startScreen, #gameOverScreen, #levelCompleteScreen, #shopScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 2em;
            text-align: center;
            z-index: 3;
            border-radius: 10px; /* Rounded corners */
        }
        #gameOverScreen, #levelCompleteScreen, #shopScreen {
            display: none; /* Hidden by default */
        }
        .game-title {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ff00ff; /* Magenta color for title */
            text-shadow: 0 0 10px #ff00ff;
        }
        .game-message {
            font-size: 1.5em;
            margin-bottom: 30px;
            color: #00ff00; /* Green color for messages */
        }
        .game-button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background: linear-gradient(45deg, #00ffff, #00aaff); /* Gradient button */
            color: #fff;
            border: none;
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            margin: 10px; /* Spacing between buttons */
        }
        .game-button:hover {
            background: linear-gradient(45deg, #00aaff, #00ffff);
            box-shadow: 0 8px 20px rgba(0, 255, 255, 0.6);
            transform: translateY(-2px);
        }
        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 255, 255, 0.4);
        }

        /* Shop specific styles */
        #shopItems {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px; /* Gap between cards */
            margin-top: 30px;
            max-width: 90%; /* Adjust max width for responsiveness */
            padding: 10px;
            overflow-y: auto; /* Enable scrolling if too many items */
            max-height: 60vh; /* Limit height to prevent overflow on small screens */
        }
        .shop-item {
            background: rgba(255, 255, 255, 0.08); /* Slightly more transparent */
            border: 2px solid #00ffff;
            border-radius: 12px; /* Slightly more rounded */
            padding: 15px;
            width: 180px; /* Fixed width for cards */
            min-height: 250px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4); /* Stronger glow */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative; /* For image positioning */
        }
        .shop-item:hover {
            transform: translateY(-8px); /* More pronounced hover */
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }
        .shop-item h3 {
            color: #ff00ff;
            margin-top: 5px; /* Adjust margin */
            margin-bottom: 8px;
            font-size: 1.4em;
            text-shadow: 0 0 5px #ff00ff;
        }
        .shop-item .item-image {
            width: 70px; /* Size for sprite preview */
            height: 70px;
            object-fit: contain; /* Ensure image fits without distortion */
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
        }
        .shop-item p {
            font-size: 0.85em;
            color: #c0c0c0; /* Lighter grey for description */
            flex-grow: 1;
            margin-bottom: 12px;
            line-height: 1.3;
        }
        .shop-item .cost {
            font-size: 1.1em;
            font-weight: bold;
            color: #00ff00;
            margin-bottom: 15px;
            text-shadow: 0 0 3px #00ff00;
        }
        .shop-item button {
            width: 95%; /* Wider button */
            padding: 10px 15px; /* More padding */
            font-size: 1em;
            background: linear-gradient(90deg, #00ff00, #00cc00); /* Brighter green gradient */
            box-shadow: 0 4px 12px rgba(0, 255, 0, 0.5); /* Stronger button shadow */
            border-radius: 6px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        .shop-item button:disabled {
            background: #444; /* Darker disabled state */
            color: #aaa;
            cursor: not-allowed;
            box-shadow: none;
            text-shadow: none;
        }
        .shop-item button:hover:disabled {
            transform: none;
            box-shadow: none;
        }
        #exitShopButton {
            margin-top: 40px; /* More space above the button */
            padding: 18px 40px; /* Larger exit button */
            font-size: 1.4em;
            background: linear-gradient(45deg, #ff6600, #ff0000); /* Orange-red gradient */
            box-shadow: 0 6px 20px rgba(255, 102, 0, 0.6);
        }
        #exitShopButton:hover {
            background: linear-gradient(45deg, #ff0000, #ff6600);
            box-shadow: 0 10px 25px rgba(255, 102, 0, 0.8);
        }
        #musicControl {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            color: #00ffff;
            font-size: 0.9em;
            z-index: 2;
        }
        #musicVolume {
            width: 80px;
        }
        #bossHealthBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background-color: #333;
            border: 2px solid #ff0000;
            border-radius: 5px;
            overflow: hidden;
            display: none; /* Hidden by default */
            z-index: 2;
        }
        #bossHealthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #ff9900);
            transition: width 0.1s ease-out;
        }
        #bossHealthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 0 0 3px black;
        }
        /* New styles for perk indicators */
        #perkIndicators {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 2;
            font-size: 0.9em;
            color: #fff;
            text-shadow: 0 0 3px black;
        }
        .perk-indicator.cooldown {
            color: #ffcc00;
        }
        .perk-indicator.ready {
            color: #00ff00;
        }
        .perk-indicator.active {
            color: #00ffff;
        }
        .perk-indicator.charging { /* New style for charging state */
            color: #ff6600;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2em;
            }
            .game-message {
                font-size: 1.1em;
            }
            .game-button {
                padding: 10px 20px;
                font-size: 0.9em;
            }
            #scoreboard {
                font-size: 0.9em;
                top: 10px;
                left: 10px;
            }
            #shopItems {
                flex-direction: column;
                align-items: center;
                gap: 12px;
                max-height: 70vh; /* Adjust for smaller screens */
            }
            .shop-item {
                width: 85%;
                max-width: 280px;
                padding: 12px;
                min-height: 200px;
            }
            .shop-item h3 {
                font-size: 1.2em;
            }
            .shop-item p {
                font-size: 0.75em;
            }
            .shop-item .cost {
                font-size: 0.9em;
            }
            .shop-item button {
                font-size: 0.85em;
                padding: 8px 12px;
            }
            #exitShopButton {
                padding: 15px 30px;
                font-size: 1.1em;
                margin-top: 25px;
            }
            #musicControl {
                flex-direction: column;
                align-items: flex-end;
                right: 5px;
                bottom: 5px;
            }
            #musicVolume {
                width: 60px;
            }
            #bossHealthBar {
                width: 80%;
                height: 20px;
            }
            #perkIndicators {
                top: 10px;
                right: 10px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="scoreboard">Score: 0 | Lives: 3 | High Score: 0</div>

        <div id="startScreen">
            <div class="game-title">ðŸš€ Galactic Defender</div>
            <div class="game-message">Defend the galaxy from invading forces!</div>
            <button id="startButton" class="game-button">Start Game</button>
        </div>

        <div id="levelCompleteScreen">
            <div class="game-title">Level <span id="currentLevelDisplay">1</span> Complete!</div>
            <div class="game-message">Enemies defeated! Prepare for the next challenge.</div>
            <button id="goToShopButton" class="game-button">Go to Shop</button>
            <button id="continueGameButton" class="game-button">Continue Game</button>
        </div>

        <div id="shopScreen">
            <div class="game-title">ðŸ›’ Upgrade Shop</div>
            <div class="game-message">Current Score: <span id="shopScoreDisplay">0</span></div>
            <div id="shopItems">
                <!-- Shop items will be dynamically loaded here -->
            </div>
            <button id="exitShopButton" class="game-button">Exit Shop & Continue</button>
        </div>

        <div id="gameOverScreen">
            <div class="game-title">Game Over!</div>
            <div id="finalScore" class="game-message">Your Score: 0</div>
            <button id="restartButton" class="game-button">Play Again</button>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="bossHealthBar">
            <div id="bossHealthFill"></div>
            <span id="bossHealthText"></span>
        </div>

        <div id="musicControl">
            <label for="musicVolume">Music Volume:</label>
            <input type="range" id="musicVolume" min="-30" max="0" value="-10" step="1">
        </div>

        <div id="perkIndicators">
            <!-- Perk indicators will be dynamically added here -->
        </div>
    </div>

    <script>
        // Ensure Tone.js is available before proceeding
        if (typeof Tone === 'undefined') {
            console.error("Tone.js not loaded. Please check the script include.");
        }

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreboard = document.getElementById("scoreboard");
        const startScreen = document.getElementById("startScreen");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const levelCompleteScreen = document.getElementById("levelCompleteScreen");
        const shopScreen = document.getElementById("shopScreen");
        const startButton = document.getElementById("startButton");
        const goToShopButton = document.getElementById("goToShopButton");
        const continueGameButton = document.getElementById("continueGameButton");
        const exitShopButton = document.getElementById("exitShopButton");
        const restartButton = document.getElementById("restartButton");
        const finalScoreDisplay = document.getElementById("finalScore");
        const currentLevelDisplay = document.getElementById("currentLevelDisplay");
        const shopScoreDisplay = document.getElementById("shopScoreDisplay");
        const shopItemsContainer = document.getElementById("shopItems");
        const musicVolumeControl = document.getElementById("musicVolume");
        const bossHealthBar = document.getElementById("bossHealthBar");
        const bossHealthFill = document.getElementById("bossHealthFill");
        const bossHealthText = document.getElementById("bossHealthText");
        const perkIndicatorsContainer = document.getElementById("perkIndicators");


        // Set initial canvas dimensions
        canvas.width = window.innerWidth > 900 ? 900 : window.innerWidth * 0.9;
        canvas.height = window.innerHeight > 700 ? 700 : window.innerHeight * 0.8;

        // --- SPRITE LOADING ---
        // Player Ship Sprites
        const playerShipImages = {
            'model_0': new Image(), // Default starting ship (Ship_1.png)
            'model_1': new Image(), // Upgrade 1 (Ship_2.png)
            'model_2': new Image()  // Upgrade 2 (Ship_3.png)
        };
        playerShipImages['model_0'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/Ship_1.png";
        playerShipImages['model_1'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/Ship_2.png";
        playerShipImages['model_2'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/Ship_3.png";

        // Add error handling for player ship images
        for (const key in playerShipImages) {
            playerShipImages[key].onerror = () => {
                console.error(`Failed to load player ship sprite: ${playerShipImages[key].src}`);
                // Fallback to basic shape if image fails to load
                playerShipType = 'basic_fallback_shape'; // Set a fallback type
            };
        }

        // Enemy Ship Sprites
        const enemyShipImages = {
            'basic': new Image(),    // Common enemy (Ship_4.png)
            'advanced': new Image(), // Advanced enemy (Ship_5.png)
            'ufo': new Image()       // New UFO enemy (ufo.png)
        };
        enemyShipImages['basic'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/Ship_4.png";
        enemyShipImages['advanced'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/Ship_5.png";
        enemyShipImages['ufo'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/ufo.png";

        // Add error handling for enemy ship images
        for (const key in enemyShipImages) {
            enemyShipImages[key].onerror = () => {
                console.error(`Failed to load enemy ship sprite: ${enemyShipImages[key].src}`);
                // Fallback to drawing shapes if images fail
            };
        }

        // Boss Ship Sprites
        const bossImages = {
            'level_1_boss': new Image(),
            'level_2_boss': new Image(),
            'level_3_boss': new Image(),
            'level_4_boss': new Image(),
            'level_5_boss': new Image(),
            'level_6_boss': new Image(),
            'level_7_boss': new Image()
        };
        bossImages['level_1_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_1_Better_Model_Upgrade.png";
        bossImages['level_2_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_2_Aerodynamics_Upgrade.png";
        bossImages['level_3_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_3_Better_Model_Upgrade.png";
        bossImages['level_4_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_4_Light_Weight_Upgrade.png";
        bossImages['level_5_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_5_Light_Weight_Upgrade.png";
        bossImages['level_6_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_6_Light_Weight_Upgrade.png";
        bossImages['level_7_boss'].src = "https://raw.githubusercontent.com/xohbeats/starship/main/image/TM_7_Better_Model_Upgrade.png";


        for (const key in bossImages) {
            bossImages[key].onerror = () => {
                console.error(`Failed to load boss sprite: ${bossImages[key].src}`);
            };
        }
        // --- END SPRITE LOADING ---


        // Game state variables
        let score = 0;
        let lives = 3;
        let maxLives = 3; // New: for health upgrades
        let highScore = localStorage.getItem("galacticDefenderHighScore") || 0;
        let gameStarted = false;
        let currentLevel = 1;
        let enemiesToSpawnThisLevel = 10; // Base enemies per level
        let enemiesSpawnedThisLevel = 0;
        let enemiesRemainingThisLevel = 0; // Tracks enemies currently on screen + those yet to spawn

        let difficultySpeed = 2;
        let enemySpawnRate = 1200; // Milliseconds
        let lastSpawnTime = 0;
        let animationFrameId;

        let currentBoss = null; // Stores the active boss object

        // Player upgrade states
        let playerShipType = 'model_0'; // Start with the default sprite 'model_0'
        let playerFireRateLevel = 1; // 1 (default), 2, 3
        let baseFireDelay = 200; // Milliseconds between shots
        let lastShotTime = 0;

        // --- NEW PERK & ABILITY VARIABLES ---
        let playerBulletDamage = 1; // Base bullet damage
        let playerBulletRadius = 4; // Base bullet radius
        let enemySpeedMultiplier = 1; // Base enemy speed multiplier

        let hasSpacebeam = false; // Unlocked via shop
        let spacebeamCooldown = 15000; // 15 seconds
        let lastSpacebeamTime = 0;
        let spacebeamChargeTime = 1400; // 1.4 seconds
        let spacebeamActiveDuration = 500; // 0.5 seconds
        let isSpacebeamCharging = false; // New state for charging
        let isSpacebeamFiring = false;
        const SPACEBEAM_DAMAGE = 5; // Damage per frame/tick for spacebeam

        let hasShield = false; // Unlocked via shop
        let shieldCooldown = 20000; // 20 seconds
        let lastShieldTime = 0;
        let shieldActiveDuration = 3000; // 3 seconds
        let isPlayerInvincible = false;

        // UFO Beam specific variables
        let ufoBeams = []; // Array to hold active UFO beams
        const UFO_BEAM_COOLDOWN = 5000; // 5 seconds
        const UFO_BEAM_CHARGE_DURATION = 1000; // 1 second charge time for UFO beam
        const UFO_BEAM_ACTIVE_DURATION = 500; // 0.5 seconds active time for UFO beam
        const UFO_BEAM_DAMAGE = 1; // Damage per tick for UFO beam
        // --- END NEW PERK & ABILITY VARIABLES ---

        // --- GAME STATE MANAGEMENT ---
        let gameState = 'start'; // 'start', 'playing', 'levelCompleteAnimation', 'levelCompleteScreenDisplayed', 'shop', 'gameOver'
        let animationStartTime = 0; // For level complete animation timing
        // --- END GAME STATE MANAGEMENT ---

        // Audio debounce for hit sounds
        let lastHitSoundPlayTime = 0;
        const hitSoundDebounceTime = 50; // milliseconds

        // --- NEW PERK VARIABLES (in-game collectibles) ---
        let perks = []; // Array to hold active in-game perk objects
        const PERK_DROP_CHANCE = 0.15; // 15% chance for an enemy to drop a perk
        const PERK_TYPES = ['heart', 'speedBoost', 'fireRateBoost'];
        const PERK_DURATION = 5000; // 5 seconds for temporary boosts
        let playerTempSpeedMultiplier = 1; // For speed boost perk
        let playerTempFireRateMultiplier = 1; // For fire rate boost perk
        let speedBoostEndTime = 0;
        let fireRateBoostEndTime = 0;
        // --- END NEW PERK VARIABLES ---


        // Tone.js setup for sound effects
        const shootSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.01,
                release: 0.1
            }
        }).toDestination();

        const hitSynth = new Tone.NoiseSynth({
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.2
            }
        }).toDestination();

        // New sound for collecting perks
        const collectPerkSound = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-game-bonus-pickup-176.mp3"); // Changed URL
        collectPerkSound.volume.value = -10;
        collectPerkSound.toDestination();
        collectPerkSound.onerror = () => console.error(`Failed to load collect perk sound: ${collectPerkSound.url}`);


        // --- NEW: Dynamic Laser Sounds ---
        const laserSounds = {
            // Corrected URLs to use hyphens instead of spaces
            'model_0': new Tone.Player("https://raw.githubusercontent.com/xohbeats/starship/main/audio/main-player-laser-sound.mp3"),
            'model_1': new Tone.Player("https://raw.githubusercontent.com/xohbeats/starship/main/audio/ship-2-laser-sound.mp3"),
            'model_2': new Tone.Player("https://raw.githubusercontent.com/xohbeats/starship/main/audio/ship-3-laser-sound.mp3")
        };

        // Ensure sounds are loaded and ready
        for (const key in laserSounds) {
            laserSounds[key].volume.value = -10; // Set a default volume for laser sounds
            laserSounds[key].autostart = false; // Don't autostart
            laserSounds[key].loop = false; // Don't loop
            laserSounds[key].toDestination(); // Connect to output
            laserSounds[key].onerror = () => console.error(`Failed to load laser sound: ${laserSounds[key].url}`);
        }

        // --- NEW: Spacebeam Charging Sound ---
        const spacebeamChargeSound = new Tone.Player("https://raw.githubusercontent.com/xohbeats/starship/main/audio/spacebeam-audio.mp3");
        spacebeamChargeSound.volume.value = -5; // Adjust volume as needed
        spacebeamChargeSound.autostart = false;
        spacebeamChargeSound.loop = false;
        spacebeamChargeSound.toDestination(); // Connect to output
        spacebeamChargeSound.onerror = () => console.error(`Failed to load spacebeam sound: ${spacebeamChargeSound.url}`);

        // --- END NEW: Dynamic Laser Sounds ---


        // Background Music Player
        const backgroundMusic = new Tone.Player({
            url: "https://raw.githubusercontent.com/xohbeats/starship/main/audio/soundtrack.mp3",
            loop: true,
            autostart: false, // Start manually when game begins
            volume: musicVolumeControl.value // Initial volume from slider
        }).toDestination();

        // Music volume control event listener
        musicVolumeControl.addEventListener('input', () => {
            backgroundMusic.volume.value = parseFloat(musicVolumeControl.value);
        });

        // Starfield background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speed = Math.random() * 0.5 + 0.1;
                this.opacity = Math.random();
            }

            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * canvas.width;
                }
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const stars = [];
        const numStars = 200; // Increased number of stars for better coverage
        for (let i = 0; i < numStars; i++) {
            stars.push(new Star());
        }

        // Player Spaceship
        class PlayerSpaceship {
            constructor() {
                this.width = 80; // Display width of the ship (adjusted for new sprites)
                this.height = 80; // Display height of the ship (adjusted for new sprites)
                this.x = canvas.width / 2;
                this.y = canvas.height - this.height - 30; // Initial start position
                this.speed = 7; // Base speed
                this.dx = 0; // Delta X for smooth movement
                this.dy = 0; // Delta Y for smooth movement
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const currentShipImage = playerShipImages[playerShipType];

                if (currentShipImage && currentShipImage.complete && currentShipImage.naturalWidth !== 0) {
                    // Draw the loaded sprite image
                    ctx.drawImage(currentShipImage, -this.width / 2, -this.height / 2, this.width, this.height);
                } else {
                    // Fallback to a basic shape if image not loaded or failed
                    ctx.fillStyle = '#00ffff'; // Cyan body
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height / 2); // Top point
                    ctx.lineTo(this.width / 2, this.height / 2); // Bottom right
                    ctx.lineTo(-this.width / 2, this.height / 2); // Bottom left
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#66ccff'; // Lighter blue for cockpit
                    ctx.beginPath();
                    ctx.arc(0, -this.height / 4, this.width * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw Shield if active
                if (isPlayerInvincible) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.7, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)'; // Cyan glow
                    ctx.lineWidth = 5;
                    ctx.shadowColor = 'rgba(0, 255, 255, 1)';
                    ctx.shadowBlur = 20;
                    ctx.stroke();
                    ctx.shadowBlur = 0; // Reset shadow
                }


                // Engine exhaust (dynamic, common to all ships, can be removed if part of sprite)
                ctx.fillStyle = `rgba(255, ${Math.random() * 100 + 150}, 0, 0.8)`;
                ctx.beginPath();
                ctx.moveTo(-this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.2, this.height / 2 + Math.random() * 10 + 10);
                ctx.lineTo(-this.width * 0.2, this.height / 2 + Math.random() * 10 + 10);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            move(dirX, dirY) {
                // Apply temporary speed boost if active
                const currentSpeed = this.speed * playerTempSpeedMultiplier;
                this.dx = dirX * currentSpeed;
                this.dy = dirY * currentSpeed;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;

                // Boundary checks for X-axis
                if (this.x - this.width / 2 < 0) this.x = this.width / 2;
                if (this.x + this.width / 2 > canvas.width) this.x = canvas.width - this.width / 2;

                // Boundary checks for Y-axis
                if (this.y - this.height / 2 < 0) this.y = this.height / 2;
                if (this.y + this.height / 2 > canvas.height) this.y = canvas.height - this.height / 2;

                // Deceleration
                this.dx *= 0.8;
                this.dy *= 0.8;
            }
        }

        // Player Bullet
        class Bullet {
            constructor(x, y, angle = -Math.PI / 2) { // Default angle is straight up
                this.x = x;
                this.y = y;
                this.radius = playerBulletRadius; // Dynamic radius
                this.speed = 10; // Base speed
                this.damage = playerBulletDamage; // Dynamic damage
                this.dx = this.speed * Math.cos(angle);
                this.dy = this.speed * Math.sin(angle);
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
            }

            draw() {
                ctx.fillStyle = "lime"; // Green bullet
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.shadowColor = "lime";
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }

        // Enemy Bullet (fired by bosses/advanced enemies)
        class EnemyBullet {
            constructor(x, y, targetX, targetY, color = "orange") { // Default to orange if not provided
                this.x = x;
                this.y = y;
                this.radius = 6;
                this.speed = 5; // Base speed
                this.damage = 1; // Enemy bullets deal 1 damage
                this.color = color;

                // Calculate direction towards target
                const angle = Math.atan2(targetY - y, targetX - x);
                this.dx = Math.cos(angle) * this.speed;
                this.dy = Math.sin(angle) * this.speed;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }
        const enemyBullets = []; // Array to hold enemy bullets

        // UFO Abduction Beam Class
        class UfoBeam {
            constructor(ufoX, ufoY, ufoWidth, timestamp) {
                this.x = ufoX;
                this.y = ufoY + ufoWidth / 2; // Start from bottom of UFO
                this.width = ufoWidth * 0.8; // Beam width
                this.height = canvas.height - this.y; // Extends to bottom of canvas
                this.damage = UFO_BEAM_DAMAGE;
                this.chargeDuration = UFO_BEAM_CHARGE_DURATION; // New: charge time
                this.activeDuration = UFO_BEAM_ACTIVE_DURATION; // New: active duration
                this.startTime = timestamp; // When the beam started its charge
                this.fireTime = this.startTime + this.chargeDuration; // When the beam becomes active
                this.endTime = this.fireTime + this.activeDuration; // When the beam disappears
            }

            update(timestamp) {
                // Beam is active after charge time and for a fixed duration
                if (timestamp < this.fireTime) {
                    return 'charging'; // Still charging
                } else if (timestamp >= this.fireTime && timestamp < this.endTime) {
                    return 'active'; // Beam is active
                }
                return 'inactive'; // Mark for removal
            }

            draw(timestamp) {
                const status = this.update(timestamp);
                if (status === 'inactive') return;

                ctx.save();
                if (status === 'charging') {
                    const chargeProgress = (timestamp - this.startTime) / this.chargeDuration;
                    const currentBeamHeight = this.height * chargeProgress;
                    const currentBeamY = this.y + (this.height - currentBeamHeight); // Grow from bottom up

                    ctx.fillStyle = `rgba(0, 255, 0, ${0.1 + chargeProgress * 0.3})`; // Faint green, increasing opacity
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
                    ctx.shadowBlur = 5 + chargeProgress * 10;
                    ctx.fillRect(this.x - this.width / 2, this.y, this.width, currentBeamHeight); // Draw from UFO down
                } else if (status === 'active') {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Green beam
                    ctx.shadowColor = 'rgba(0, 255, 0, 1)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
                }
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        let ufoBeamsActive = []; // Array to hold active UFO beams

        // NEW Perk Class
        class Perk {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 15;
                this.speed = 1; // Perks move slower than enemies
                this.type = type; // 'heart', 'speedBoost', 'fireRateBoost'
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'heart') {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(-this.radius * 0.4, -this.radius * 0.4, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.arc(this.radius * 0.4, -this.radius * 0.4, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.lineTo(0, this.radius);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = 'white'; // Small highlight
                    ctx.beginPath();
                    ctx.arc(-this.radius * 0.2, -this.radius * 0.6, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'speedBoost') {
                    ctx.fillStyle = 'cyan';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(this.radius, this.radius);
                    ctx.lineTo(-this.radius, this.radius);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('SPD', 0, 0);
                } else if (this.type === 'fireRateBoost') {
                    ctx.fillStyle = 'yellow';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('FR', 0, 0);
                }
                ctx.restore();
            }
        }


        // Base Enemy Class
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 60; // Display width of the enemy ship (adjusted for new sprites)
                this.height = 60; // Display height of the enemy ship (adjusted for new sprites)
                this.speed = difficultySpeed * enemySpeedMultiplier; // Apply enemy slow perk
                this.type = type; // e.g., 'basic', 'advanced', 'ufo'
                this.health = 1;
                this.oscillationOffset = Math.random() * Math.PI * 2; // For frantic movement
                // this.trackingSpeed = 0.05; // How fast enemies track the player - REMOVED FOR REGULAR ENEMIES

                // UFO specific
                this.lastUfoBeamTime = 0;
                this.ufoBeamCooldown = UFO_BEAM_COOLDOWN;


                if (type === 'advanced') {
                    this.health = 3; // Advanced enemies have more health
                } else if (type === 'ufo') {
                    this.health = 2; // UFOs have medium health
                    this.speed = (difficultySpeed * enemySpeedMultiplier) * 0.7; // UFOs are slower
                }
            }

            update(timestamp) {
                this.y += this.speed;

                if (this.type === 'advanced') {
                    // Frantic movement: oscillate left and right - MADE MORE FRANTIC
                    this.x += Math.sin(timestamp * 0.02 + this.oscillationOffset) * 4;
                    // Keep advanced enemy within horizontal bounds
                    if (this.x < this.width / 2) this.x = this.width / 2;
                    if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
                } else if (this.type === 'ufo') {
                    // Slower scroll-down, but still with some subtle horizontal drift
                    this.x += Math.sin(timestamp * 0.005 + this.oscillationOffset) * 0.5;
                    if (this.x < this.width / 2) this.x = this.width / 2;
                    if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;

                    // UFO Abduction Beam attack
                    // Only fire if on screen and not too low, and cooldown is ready
                    if (timestamp - this.lastUfoBeamTime > this.ufoBeamCooldown && this.y > 0 && this.y < canvas.height * 0.6) {
                        ufoBeamsActive.push(new UfoBeam(this.x, this.y, this.width, timestamp)); // Pass current timestamp
                        this.lastUfoBeamTime = timestamp;
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const currentEnemyImage = enemyShipImages[this.type];

                if (currentEnemyImage && currentEnemyImage.complete && currentEnemyImage.naturalWidth !== 0) {
                    // Draw the loaded sprite image
                    ctx.drawImage(currentEnemyImage, -this.width / 2, -this.height / 2, this.width, this.height);
                } else {
                    // Fallback to drawing shapes if images fail
                    if (this.type === 'basic') {
                        ctx.fillStyle = '#ff0000'; // Red body
                        ctx.beginPath();
                        ctx.moveTo(0, this.height / 2);
                        ctx.lineTo(this.width / 2, -this.height / 2);
                        ctx.lineTo(-this.width / 2, -this.height / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (this.type === 'advanced') {
                        ctx.fillStyle = '#ffff00'; // Yellow body for advanced
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    } else if (this.type === 'ufo') {
                        ctx.fillStyle = '#9900ff'; // Purple body for UFO
                        ctx.beginPath();
                        ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Optionally draw health bar for multi-hit enemies
                if (this.health > 0 && this.health < (this.type === 'advanced' ? 3 : (this.type === 'ufo' ? 2 : 1))) {
                    const barWidth = this.width * 0.8;
                    const barHeight = 4;
                    const barX = -barWidth / 2;
                    const barY = -this.height / 2 - barHeight - 2; // Above the enemy
                    ctx.fillStyle = '#333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    const maxEnemyHealth = (this.type === 'advanced' ? 3 : (this.type === 'ufo' ? 2 : 1));
                    ctx.fillStyle = `hsl(${this.health / maxEnemyHealth * 120}, 100%, 50%)`; // Green to red
                    ctx.fillRect(barX, barY, barWidth * (this.health / maxEnemyHealth), barHeight);
                }

                ctx.restore();
            }
        }

        // Boss Class
        class Boss {
            constructor(type) {
                this.type = type;
                this.width = 150; // Boss size
                this.height = 150;
                this.x = canvas.width / 2;
                this.y = 100; // Start higher up
                this.speed = 1.5; // Base boss horizontal speed
                this.dx = this.speed;
                this.initialHealth = 10;
                this.fireRate = 1000; // Milliseconds between shots

                // Define specific properties for each boss type and bullet color
                switch (type) {
                    case 'level_1_boss':
                        this.initialHealth = 10;
                        this.fireRate = 1000;
                        this.speed = 1.5;
                        this.bulletColor = '#FF0000'; // Red
                        break;
                    case 'level_2_boss':
                        this.initialHealth = 15;
                        this.fireRate = 800;
                        this.speed = 1.8;
                        this.bulletColor = '#00FFFF'; // Cyan
                        break;
                    case 'level_3_boss':
                        this.initialHealth = 20;
                        this.fireRate = 700;
                        this.speed = 2.0;
                        this.bulletColor = '#FFFF00'; // Yellow
                        break;
                    case 'level_4_boss':
                        this.initialHealth = 25;
                        this.fireRate = 600;
                        this.speed = 2.2;
                        this.bulletColor = '#FF00FF'; // Magenta
                        break;
                    case 'level_5_boss':
                        this.initialHealth = 30;
                        this.fireRate = 550;
                        this.speed = 2.5;
                        this.bulletColor = '#00FF00'; // Green
                        break;
                    case 'level_6_boss':
                        this.initialHealth = 35;
                        this.fireRate = 500;
                        this.speed = 2.7;
                        this.bulletColor = '#FFA500'; // Orange
                        break;
                    case 'level_7_boss':
                        this.initialHealth = 40;
                        this.fireRate = 450;
                        this.speed = 3.0;
                        this.bulletColor = '#FFFFFF'; // White
                        break;
                    default:
                        // Fallback for undefined bosses
                        this.initialHealth = 5;
                        this.fireRate = 1500;
                        this.speed = 1.0;
                        this.bulletColor = '#FF0000'; // Default to red
                        break;
                }

                this.health = this.initialHealth;
                this.lastFireTime = 0;
            }

            update(timestamp) {
                // Horizontal movement
                this.x += this.dx;
                if (this.x + this.width / 2 > canvas.width || this.x - this.width / 2 < 0) {
                    this.dx *= -1; // Reverse direction
                }

                // Firing logic (Boss targets player)
                if (timestamp - this.lastFireTime > this.fireRate) {
                    switch (this.type) {
                        case 'level_1_boss':
                            enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, player.x, player.y, this.bulletColor));
                            break;
                        case 'level_2_boss':
                            // Two bullets, slightly offset
                            enemyBullets.push(new EnemyBullet(this.x - 15, this.y + this.height / 2, player.x, player.y, this.bulletColor));
                            enemyBullets.push(new EnemyBullet(this.x + 15, this.y + this.height / 2, player.x, player.y, this.bulletColor));
                            break;
                        case 'level_3_boss':
                            // Three Y-shape bullets
                            const angleOffset = Math.PI / 12; // 15 degrees in radians
                            enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, player.x, player.y, this.bulletColor)); // Straight
                            // Aim slightly to the left/right of the player's current position, but ensure they move downwards
                            enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, player.x - 100, player.y + 200, this.bulletColor)); // Left-angled
                            enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, player.x + 100, player.y + 200, this.bulletColor)); // Right-angled
                            break;
                        case 'level_4_boss':
                            // Rapid burst of 3 single bullets
                            const burstDelay = 100; // ms between burst shots
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, player.x, player.y, this.bulletColor));
                                }, i * burstDelay);
                            }
                            break;
                        case 'level_5_boss':
                            // Wider spread shot (5 bullets)
                            const spreadAngle5 = Math.PI / 8; // Total spread angle
                            const numBullets5 = 5;
                            for (let i = 0; i < numBullets5; i++) {
                                const angle = Math.atan2(player.y - (this.y + this.height / 2), player.x - this.x) - (spreadAngle5 / 2) + (i * spreadAngle5 / (numBullets5 - 1));
                                enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, this.x + Math.cos(angle) * 1000, this.y + this.height / 2 + Math.sin(angle) * 1000, this.bulletColor));
                            }
                            break;
                        case 'level_6_boss':
                            // Cone of 7 bullets, slightly faster
                            const spreadAngle6 = Math.PI / 6; // Total spread angle
                            const numBullets6 = 7;
                            for (let i = 0; i < numBullets6; i++) {
                                const angle = Math.atan2(player.y - (this.y + this.height / 2), player.x - this.x) - (spreadAngle6 / 2) + (i * spreadAngle6 / (numBullets6 - 1));
                                // Make bullets slightly faster by adjusting target distance
                                enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, this.x + Math.cos(angle) * 1500, this.y + this.height / 2 + Math.sin(angle) * 1500, this.bulletColor));
                            }
                            break;
                        case 'level_7_boss':
                            // Very wide, dense spread of 10-12 bullets, very fast
                            const spreadAngle7 = Math.PI / 3; // Wider spread angle
                            const numBullets7 = 12;
                            for (let i = 0; i < numBullets7; i++) {
                                const angle = Math.atan2(player.y - (this.y + this.height / 2), player.x - this.x) - (spreadAngle7 / 2) + (i * spreadAngle7 / (numBullets7 - 1));
                                // Make bullets much faster
                                enemyBullets.push(new EnemyBullet(this.x, this.y + this.height / 2, this.x + Math.cos(angle) * 2000, this.y + this.height / 2 + Math.sin(angle) * 2000, this.bulletColor));
                            }
                            break;
                    }
                    this.lastFireTime = timestamp;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const currentBossImage = bossImages[this.type];

                if (currentBossImage && currentBossImage.complete && currentBossImage.naturalWidth !== 0) {
                    ctx.drawImage(currentBossImage, -this.width / 2, -this.height / 2, this.width, this.height);
                } else {
                    // Fallback shape for boss
                    ctx.fillStyle = '#8800ff'; // Purple
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-this.width * 0.1, -this.height * 0.7, this.width * 0.2, this.height * 0.2);
                }

                ctx.restore();
            }

            updateHealthBar() {
                bossHealthBar.style.display = 'block';
                const healthPercentage = (this.health / this.initialHealth) * 100;
                bossHealthFill.style.width = `${healthPercentage}%`;
                bossHealthFill.style.background = `linear-gradient(to right, hsl(${healthPercentage * 1.2}, 100%, 50%), #ff9900)`; // Color changes with health
                bossHealthText.innerText = `BOSS: ${this.health}/${this.initialHealth}`;
            }

            hideHealthBar() {
                bossHealthBar.style.display = 'none';
            }
        }


        const player = new PlayerSpaceship();
        const bullets = [];
        const enemies = [];
        let keys = {};

        // Shop Items Definition
        const shopItems = [
            {
                id: 'ship_model_1',
                name: 'Model 1 Fighter',
                description: 'An improved basic fighter.',
                cost: 100,
                type: 'ship',
                upgradeTo: 'model_1',
                previewImage: playerShipImages['model_1'],
                purchased: false
            },
            {
                id: 'ship_model_2',
                name: 'Model 2 Interceptor',
                description: 'Faster and more agile. Requires Model 1.',
                cost: 250,
                type: 'ship',
                upgradeTo: 'model_2',
                requires: 'ship_model_1',
                previewImage: playerShipImages['model_2'],
                purchased: false
            },
            {
                id: 'firerate_2',
                name: 'Rapid Fire I',
                description: 'Increases your firing speed.',
                cost: 75,
                type: 'firerate',
                level: 2,
                purchased: false
            },
            {
                id: 'firerate_3',
                name: 'Rapid Fire II',
                description: 'Further increases firing speed. Requires Rapid Fire I.',
                cost: 175,
                type: 'firerate',
                level: 3,
                requires: 'firerate_2',
                purchased: false
            },
            {
                id: 'health_1',
                name: 'Hull Reinforcement',
                description: 'Adds 1 extra life.',
                cost: 120,
                type: 'health',
                purchased: false
            },
            // --- NEW SHOP ITEMS FOR PERKS ---
            {
                id: 'perk_spacebeam',
                name: 'Spacebeam',
                description: 'Unlock a powerful laser beam (Z key).',
                cost: 300,
                type: 'perk_ability',
                ability: 'spacebeam',
                purchased: false
            },
            {
                id: 'perk_shield',
                name: 'Deflector Shield',
                description: 'Unlock temporary invincibility (X key).',
                cost: 350,
                type: 'perk_ability',
                ability: 'shield',
                purchased: false
            },
            {
                id: 'perk_double_damage',
                name: 'Double Damage',
                description: 'Permanently double your bullet damage.',
                cost: 200,
                type: 'perk_permanent',
                effect: 'double_damage',
                purchased: false
            },
            {
                id: 'perk_mega_bullets',
                name: 'Mega Bullets',
                description: 'Permanently increase your bullet size.',
                cost: 150,
                type: 'perk_permanent',
                effect: 'mega_bullets',
                purchased: false
            },
            {
                id: 'perk_enemy_slow',
                name: 'Enemy Slow',
                description: 'Permanently reduce enemy movement speed.',
                cost: 250,
                type: 'perk_permanent',
                effect: 'enemy_slow',
                purchased: false
            }
            // --- END NEW SHOP ITEMS ---
        ];

        // Event Listeners for player movement and shooting
        window.addEventListener("keydown", (e) => {
            // Only allow player controls if game state is 'playing'
            if (gameState === 'playing') {
                keys[e.key] = true;
                const now = Tone.now(); // Use Tone.now() for audio scheduling consistency
                const performanceNow = performance.now(); // Use performance.now for game logic timing

                // Regular shooting
                if (e.key === " ") {
                    // Check if enough time has passed since the last shot based on fire rate
                    // Apply temporary fire rate boost
                    const currentFireDelay = baseFireDelay / (playerFireRateLevel * playerTempFireRateMultiplier);
                    if (performanceNow - lastShotTime > currentFireDelay) {
                        // Play the specific laser sound for the current ship type
                        const currentLaserSound = laserSounds[playerShipType];
                        if (currentLaserSound && currentLaserSound.loaded) {
                            // Stop and restart if already playing to allow rapid fire sound
                            if (currentLaserSound.state === 'started') {
                                currentLaserSound.stop();
                            }
                            currentLaserSound.start(Tone.now() + 0.001); // Add a small offset
                        } else {
                            // Fallback to a generic synth sound if specific sound not loaded
                            shootSynth.triggerAttack("C4", Tone.now() + 0.001); // Add a small offset
                            shootSynth.triggerRelease(Tone.now() + 0.05 + 0.001); // Release after 50ms + offset
                        }

                        // --- Bullet Firing Logic based on Ship Type ---
                        if (playerShipType === 'model_0') {
                            // Default single bullet
                            bullets.push(new Bullet(player.x, player.y - player.height / 2));
                        } else if (playerShipType === 'model_1') {
                            // Double bullets, side-by-side
                            bullets.push(new Bullet(player.x - 15, player.y - player.height / 2));
                            bullets.push(new Bullet(player.x + 15, player.y - player.height / 2));
                        } else if (playerShipType === 'model_2') {
                            // Y-shape bullets (3 bullets)
                            const angleOffset = Math.PI / 12; // 15 degrees in radians for side bullets

                            // Center bullet (straight up)
                            bullets.push(new Bullet(player.x, player.y - player.height / 2));

                            // Left angled bullet
                            bullets.push(new Bullet(player.x, player.y - player.height / 2, -Math.PI / 2 - angleOffset));

                            // Right angled bullet
                            bullets.push(new Bullet(player.x, player.y - player.height / 2, -Math.PI / 2 + angleOffset));
                        }
                        // --- End Bullet Firing Logic ---

                        lastShotTime = performanceNow;
                    }
                }

                // Spacebeam activation
                if (e.key.toLowerCase() === "z" && hasSpacebeam && !isSpacebeamFiring && !isSpacebeamCharging) {
                    if (performanceNow - lastSpacebeamTime > spacebeamCooldown) { // Use performance.now() for game logic timing
                        isSpacebeamCharging = true;
                        lastSpacebeamTime = performanceNow; // Store in ms

                        // Play spacebeam charging sound
                        if (spacebeamChargeSound.loaded) {
                            if (spacebeamChargeSound.state === 'started') {
                                spacebeamChargeSound.stop();
                            }
                            spacebeamChargeSound.start(Tone.now() + 0.001); // Add a small offset
                        }

                        // Set a timeout to activate the beam after charging
                        setTimeout(() => {
                            isSpacebeamCharging = false;
                            isSpacebeamFiring = true;
                            // Set a timeout to deactivate beam after its active duration
                            setTimeout(() => {
                                isSpacebeamFiring = false;
                                console.log("Spacebeam deactivated.");
                            }, spacebeamActiveDuration);
                            console.log("Spacebeam activated!");
                        }, spacebeamChargeTime);
                        console.log("Spacebeam charging...");
                    } else {
                        console.log("Spacebeam on cooldown!");
                    }
                }

                // Shield activation
                if (e.key.toLowerCase() === "x" && hasShield && !isPlayerInvincible) {
                    if (performanceNow - lastShieldTime > shieldCooldown) { // Use performance.now() for game logic timing
                        isPlayerInvincible = true;
                        lastShieldTime = performanceNow; // Store in ms
                        // Set a timeout to deactivate shield
                        setTimeout(() => {
                            isPlayerInvincible = false;
                            console.log("Shield deactivated.");
                        }, shieldActiveDuration);
                        console.log("Shield activated!");
                    } else {
                        console.log("Shield on cooldown!");
                    }
                }
            }
        });

        window.addEventListener("keyup", (e) => {
            if (gameState === 'playing') { // Only process keyup if game state is 'playing'
                keys[e.key] = false;
            }
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth > 900 ? 900 : window.innerWidth * 0.9;
            canvas.height = window.innerHeight > 700 ? 700 : window.innerHeight * 0.8;
            // Reposition player if necessary
            player.x = canvas.width / 2;
            player.y = canvas.height - player.height - 30;
            // Clear and redraw everything
            if (gameStarted) {
                cancelAnimationFrame(animationFrameId);
                gameLoop(performance.now()); // Restart loop with current timestamp
            }
        });

        function spawnEnemy(timestamp) {
            if (gameState !== 'playing' || enemiesSpawnedThisLevel >= enemiesToSpawnThisLevel) return; // Only spawn if playing
            if (currentBoss) return; // Don't spawn regular enemies if boss is active

            // Only spawn if enough time has passed since last spawn
            if (timestamp - lastSpawnTime > enemySpawnRate) {
                const x = Math.random() * (canvas.width - 60) + 30; // Ensure enemy spawns within bounds
                const enemyTypes = ['basic', 'basic', 'basic', 'advanced', 'ufo']; // Adjust probabilities for enemy types
                const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const newEnemy = new Enemy(x, -50, randomType);
                
                enemies.push(newEnemy);
                enemiesSpawnedThisLevel++;
                enemiesRemainingThisLevel++; // Increment count of enemies to defeat for level
                lastSpawnTime = timestamp;
            }
        }

        function updateScoreboard() {
            scoreboard.innerText = `Score: ${score} | Lives: ${lives}/${maxLives} | High Score: ${highScore} | Level: ${currentLevel}`;
        }

        function updatePerkIndicators(timestamp) {
            perkIndicatorsContainer.innerHTML = ''; // Clear previous indicators

            // Spacebeam Indicator
            if (hasSpacebeam) {
                const timeSinceLastBeam = timestamp - lastSpacebeamTime;
                const remainingCooldown = Math.max(0, spacebeamCooldown - timeSinceLastBeam);
                let status = 'ready';
                let text = `Spacebeam: READY (Z)`;

                if (isSpacebeamCharging) {
                    const chargeProgress = (timestamp - lastSpacebeamTime) / spacebeamChargeTime;
                    const remainingCharge = Math.max(0, spacebeamChargeTime - (timestamp - lastSpacebeamTime));
                    status = 'charging';
                    text = `Spacebeam: CHARGING (${Math.ceil(remainingCharge / 1000)}s)`;
                } else if (isSpacebeamFiring) {
                    status = 'active';
                    text = `Spacebeam: ACTIVE`;
                } else if (remainingCooldown > 0) {
                    status = 'cooldown';
                    text = `Spacebeam: ${Math.ceil(remainingCooldown / 1000)}s CD`;
                }
                const indicator = `<div class="perk-indicator ${status}">${text}</div>`;
                perkIndicatorsContainer.innerHTML += indicator;
            }

            // Shield Indicator
            if (hasShield) {
                const timeSinceLastShield = timestamp - lastShieldTime;
                const remainingCooldown = Math.max(0, shieldCooldown - timeSinceLastShield);
                const status = isPlayerInvincible ? 'active' : (remainingCooldown > 0 ? 'cooldown' : 'ready');
                const text = isPlayerInvincible ? `Shield: ACTIVE` : (remainingCooldown > 0 ? `Shield: ${Math.ceil(remainingCooldown / 1000)}s CD` : `Shield: READY (X)`);
                const indicator = `<div class="perk-indicator ${status}">${text}</div>`;
                perkIndicatorsContainer.innerHTML += indicator;
            }

            // Permanent Perk Indicators (just show if owned)
            if (playerBulletDamage > 1) {
                perkIndicatorsContainer.innerHTML += `<div class="perk-indicator active">Double Damage</div>`;
            }
            if (playerBulletRadius > 4) { // Assuming 4 is base radius
                perkIndicatorsContainer.innerHTML += `<div class="perk-indicator active">Mega Bullets</div>`;
            }
            if (enemySpeedMultiplier < 1) { // Assuming 1 is base multiplier
                perkIndicatorsContainer.innerHTML += `<div class="perk-indicator active">Enemy Slow</div>`;
            }
            // Temporary perk indicators
            if (playerTempSpeedMultiplier > 1) {
                const remainingTime = Math.max(0, speedBoostEndTime - timestamp);
                perkIndicatorsContainer.innerHTML += `<div class="perk-indicator active">Speed Boost (${Math.ceil(remainingTime / 1000)}s)</div>`;
            }
            if (playerTempFireRateMultiplier > 1) {
                const remainingTime = Math.max(0, fireRateBoostEndTime - timestamp);
                perkIndicatorsContainer.innerHTML += `<div class="perk-indicator active">Fire Rate Boost (${Math.ceil(remainingTime / 1000)}s)</div>`;
            }
        }


        function increaseDifficulty() {
            difficultySpeed += 0.15; // Increase base enemy speed
            if (enemySpawnRate > 300) enemySpawnRate -= 30; // Decrease spawn interval, but not too fast
            enemiesToSpawnThisLevel += 7; // More enemies per level
            console.log(`Difficulty increased! Spawn Rate: ${enemySpawnRate}, Speed: ${difficultySpeed.toFixed(1)}, Enemies: ${enemiesToSpawnThisLevel}`);
        }

        function resetGame() {
            score = 0;
            lives = 3;
            maxLives = 3;
            currentLevel = 1;
            playerShipType = 'model_0'; // Reset to the default sprite
            playerFireRateLevel = 1;
            enemiesToSpawnThisLevel = 10;
            enemiesSpawnedThisLevel = 0;
            enemiesRemainingThisLevel = 0;
            difficultySpeed = 2;
            enemySpawnRate = 1200;
            bullets.length = 0; // Clear arrays
            enemies.length = 0;
            enemyBullets.length = 0; // Clear enemy bullets
            ufoBeamsActive.length = 0; // Clear UFO beams
            perks.length = 0; // Clear perks
            currentBoss = null; // Clear any active boss
            bossHealthBar.style.display = 'none'; // Hide boss health bar

            // Reset perk states
            playerBulletDamage = 1;
            playerBulletRadius = 4;
            enemySpeedMultiplier = 1;
            hasSpacebeam = false;
            isSpacebeamCharging = false;
            isSpacebeamFiring = false;
            lastSpacebeamTime = 0;
            hasShield = false;
            isPlayerInvincible = false;
            lastShieldTime = 0;
            playerTempSpeedMultiplier = 1; // Reset temporary speed boost
            playerTempFireRateMultiplier = 1; // Reset temporary fire rate boost
            speedBoostEndTime = 0;
            fireRateBoostEndTime = 0;
            perkIndicatorsContainer.innerHTML = ''; // Clear perk indicators

            player.x = canvas.width / 2;
            player.y = canvas.height - player.height - 30; // Reset player position

            // Reset shop items purchased status
            shopItems.forEach(item => item.purchased = false);

            updateScoreboard();
            hideAllScreens();
            gameState = 'playing'; // Set game state to playing
            animationFrameId = requestAnimationFrame(gameLoop);
            if (backgroundMusic.state === 'started') { // Only stop if playing
                backgroundMusic.stop();
            }
        }

        function hideAllScreens() {
            startScreen.style.display = "none";
            gameOverScreen.style.display = "none";
            levelCompleteScreen.style.display = "none";
            shopScreen.style.display = "none";
        }

        function showLevelCompleteScreen(timestamp) {
            gameStarted = false; // Stop general game logic
            cancelAnimationFrame(animationFrameId); // Stop the current game loop
            animationStartTime = timestamp; // Record start time for animation
            gameState = 'levelCompleteAnimation'; // Set new game state for animation
            
            // Clear remaining enemies and bullets for a clean animation
            enemies.length = 0;
            enemyBullets.length = 0;
            ufoBeamsActive.length = 0;
            perks.length = 0; // Clear perks
            currentBoss = null; // Boss is defeated
            bossHealthBar.style.display = 'none'; // Ensure boss health bar is hidden

            if (backgroundMusic.state === 'started') {
                backgroundMusic.stop();
            }
            animationFrameId = requestAnimationFrame(gameLoop); // Start new loop for animation
        }

        function showShopScreen() {
            hideAllScreens();
            shopScreen.style.display = "flex";
            shopScoreDisplay.innerText = score;
            renderShopItems();
            if (backgroundMusic.state === 'started') { // Only stop if playing
                backgroundMusic.stop();
            }
            gameState = 'shop'; // Set game state to shop
        }

        function renderShopItems() {
            shopItemsContainer.innerHTML = ''; // Clear previous items
            shopItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('shop-item');

                let imageHtml = '';
                // Only show image for ship type items
                if (item.type === 'ship' && item.previewImage && item.previewImage.complete && item.previewImage.naturalWidth !== 0) {
                    imageHtml = `<img src="${item.previewImage.src}" alt="${item.name}" class="item-image">`;
                } else if (item.type === 'ship') {
                    // Fallback for ship image if not loaded
                    imageHtml = `<div class="item-image" style="background-color:#555; display:flex; justify-content:center; align-items:center; color:white; font-size:0.8em;">No Image</div>`;
                }

                itemDiv.innerHTML = `
                    ${imageHtml}
                    <h3>${item.name}</h3>
                    <p>${item.description}</p>
                    <div class="cost">Cost: ${item.cost} Score</div>
                    <button id="buy-${item.id}" class="game-button">${item.purchased ? 'Purchased' : 'Buy'}</button>
                `;
                const buyButton = itemDiv.querySelector(`#buy-${item.id}`);

                // Disable if already purchased
                if (item.purchased) {
                    buyButton.disabled = true;
                }
                // Disable if not enough score
                if (score < item.cost) {
                    buyButton.disabled = true;
                    buyButton.innerText = 'Too Expensive';
                }
                // Disable if requirements not met
                if (item.requires) {
                    const requiredItem = shopItems.find(si => si.id === item.requires);
                    if (!requiredItem || !requiredItem.purchased) {
                        buyButton.disabled = true;
                        buyButton.innerText = `Requires ${requiredItem ? requiredItem.name : 'Previous Upgrade'}`;
                    }
                }
                // Specific logic for health upgrade (only one purchase allowed and if at max lives)
                if (item.type === 'health') {
                    if (item.purchased) {
                        buyButton.disabled = true;
                        buyButton.innerText = 'Purchased';
                    } else if (lives === maxLives) {
                        buyButton.disabled = true;
                        buyButton.innerText = 'Max Health';
                    }
                }
                // Specific logic for ship upgrades: disable if current ship is already this model or higher
                if (item.type === 'ship') {
                    // Map current player ship type to an index for comparison
                    const playerShipModels = ['model_0', 'model_1', 'model_2'];
                    const currentShipIndex = playerShipModels.indexOf(playerShipType);
                    const upgradeShipIndex = playerShipModels.indexOf(item.upgradeTo);

                    if (upgradeShipIndex <= currentShipIndex) {
                        buyButton.disabled = true;
                        buyButton.innerText = 'Equipped';
                        if (upgradeShipIndex < currentShipIndex) {
                             buyButton.innerText = 'Owned';
                        }
                    }
                }
                // Specific logic for perk_ability and perk_permanent: disable if already purchased
                if (item.type === 'perk_ability' || item.type === 'perk_permanent') {
                    if (item.purchased) {
                        buyButton.disabled = true;
                        buyButton.innerText = 'Purchased';
                    }
                }


                buyButton.addEventListener('click', () => purchaseItem(item));
                shopItemsContainer.appendChild(itemDiv);
            });
        }

        function purchaseItem(item) {
            if (score >= item.cost && !item.purchased) {
                // Check specific requirements
                if (item.requires) {
                    const requiredItem = shopItems.find(si => si.id === item.requires);
                    if (!requiredItem || !requiredItem.purchased) {
                        console.log(`Cannot purchase ${item.name}: Requires ${requiredItem.name}`);
                        return;
                    }
                }

                score -= item.cost;
                item.purchased = true; // Mark as purchased

                // Apply upgrade effect
                if (item.type === 'ship') {
                    playerShipType = item.upgradeTo;
                } else if (item.type === 'firerate') {
                    playerFireRateLevel = item.level;
                } else if (item.type === 'health') {
                    maxLives += 1; // Increase max lives
                    lives = Math.min(lives + 1, maxLives); // Also heal by 1, up to new max
                } else if (item.type === 'perk_ability') {
                    if (item.ability === 'spacebeam') {
                        hasSpacebeam = true;
                        lastSpacebeamTime = performance.now() - spacebeamCooldown; // Make it ready immediately
                    } else if (item.ability === 'shield') {
                        hasShield = true;
                        lastShieldTime = performance.now() - shieldCooldown; // Make it ready immediately
                    }
                } else if (item.type === 'perk_permanent') {
                    if (item.effect === 'double_damage') {
                        playerBulletDamage *= 2;
                    } else if (item.effect === 'mega_bullets') {
                        playerBulletRadius *= 2; // Double bullet size
                    } else if (item.effect === 'enemy_slow') {
                        enemySpeedMultiplier *= 0.7; // Reduce enemy speed to 70%
                    }
                }

                updateScoreboard();
                shopScoreDisplay.innerText = score; // Update score in shop
                renderShopItems(); // Re-render shop to update button states
                console.log(`Purchased ${item.name}! Current score: ${score}`);
            } else {
                console.log(`Cannot purchase ${item.name}. Not enough score or already purchased.`);
            }
        }

        function startNextLevel() {
            currentLevel++;
            increaseDifficulty(); // Increase difficulty for the new level
            enemiesToSpawnThisLevel = 10 + (currentLevel - 1) * 7; // Scale enemies per level
            enemiesSpawnedThisLevel = 0;
            enemiesRemainingThisLevel = 0; // Will be updated by spawnEnemy
            bullets.length = 0; // Clear player bullets
            enemies.length = 0; // Clear regular enemies
            enemyBullets.length = 0; // Clear enemy bullets
            ufoBeamsActive.length = 0; // Clear UFO beams
            perks.length = 0; // Clear perks
            currentBoss = null; // Ensure no boss from previous level lingers
            bossHealthBar.style.display = 'none'; // Hide boss health bar

            // Reset temporary perks
            playerTempSpeedMultiplier = 1;
            playerTempFireRateMultiplier = 1;
            speedBoostEndTime = 0;
            fireRateBoostEndTime = 0;

            player.x = canvas.width / 2;
            player.y = canvas.height - player.height - 30; // Reset player position

            hideAllScreens();
            gameState = 'playing'; // Set game state to playing
            animationFrameId = requestAnimationFrame(gameLoop);
            backgroundMusic.start(); // Start music when level begins
        }

        function endGame() {
            gameStarted = false; // No longer needed, gameState handles this
            cancelAnimationFrame(animationFrameId); // Stop the game loop
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("galacticDefenderHighScore", highScore);
            }
            finalScoreDisplay.innerText = `Your Score: ${score}`;
            gameOverScreen.style.display = "flex";
            updateScoreboard(); // Update scoreboard one last time to show final high score
            if (backgroundMusic.state === 'started') { // Only stop if playing
                backgroundMusic.stop();
            }
            bossHealthBar.style.display = 'none'; // Ensure boss health bar is hidden
            gameState = 'gameOver'; // Set game state to game over
        }

        function gameLoop(timestamp) {
            // Main game loop logic based on gameState
            if (gameState === 'start') {
                // Draw start screen (handled by CSS display)
                animationFrameId = requestAnimationFrame(gameLoop); // Keep looping for starfield
                return;
            } else if (gameState === 'gameOver') {
                // Draw game over screen (handled by CSS display)
                animationFrameId = requestAnimationFrame(gameLoop); // Keep looping for starfield
                return;
            } else if (gameState === 'shop') {
                // Draw shop screen (handled by CSS display)
                animationFrameId = requestAnimationFrame(gameLoop); // Keep looping for starfield
                return;
            } else if (gameState === 'levelCompleteScreenDisplayed') {
                // Draw level complete screen (handled by CSS display)
                animationFrameId = requestAnimationFrame(gameLoop); // Keep looping for starfield
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Update and draw stars regardless of game state
            stars.forEach(star => {
                star.update();
                star.draw();
            });

            if (gameState === 'playing') {
                // Update temporary perk durations
                if (playerTempSpeedMultiplier > 1 && timestamp > speedBoostEndTime) {
                    playerTempSpeedMultiplier = 1;
                    console.log("Speed Boost expired.");
                }
                if (playerTempFireRateMultiplier > 1 && timestamp > fireRateBoostEndTime) {
                    playerTempFireRateMultiplier = 1;
                    console.log("Fire Rate Boost expired.");
                }

                // Player movement
                let dirX = 0;
                let dirY = 0;
                if (keys["ArrowLeft"]) dirX = -1;
                if (keys["ArrowRight"]) dirX = 1;
                if (keys["ArrowUp"]) dirY = -1;
                if (keys["ArrowDown"]) dirY = 1;
                player.move(dirX, dirY); // Pass both directions
                player.update();
                player.draw();

                // --- Spacebeam drawing and collision ---
                if (isSpacebeamCharging) {
                    ctx.save();
                    // Draw charging animation: growing line from player
                    const chargeProgress = (timestamp - lastSpacebeamTime) / spacebeamChargeTime;
                    const beamHeight = player.y * chargeProgress;
                    const beamY = player.y - beamHeight;

                    ctx.fillStyle = `rgba(0, 255, 255, ${0.3 + chargeProgress * 0.5})`; // Increase opacity
                    ctx.shadowColor = 'rgba(0, 255, 255, 1)';
                    ctx.shadowBlur = 10 + chargeProgress * 20; // Increase blur
                    ctx.fillRect(player.x - 10, beamY, 20, beamHeight); // Narrower, growing beam
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (isSpacebeamFiring) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.7)'; // Cyan beam
                    ctx.shadowColor = 'rgba(0, 255, 255, 1)';
                    ctx.shadowBlur = 30;
                    // Draw beam from player to top of screen
                    ctx.fillRect(player.x - 20, 0, 40, player.y); // Width 40, extends from top to player's Y
                    ctx.shadowBlur = 0; // Reset shadow
                    ctx.restore();

                    // Spacebeam collision with enemies
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        // Check if enemy is within the beam's X range and above player
                        if (enemy.x + enemy.width / 2 > player.x - 20 &&
                            enemy.x - enemy.width / 2 < player.x + 20 &&
                            enemy.y + enemy.height / 2 > 0 && // Ensure enemy is on screen
                            enemy.y - enemy.height / 2 < player.y) {

                            enemy.health -= SPACEBEAM_DAMAGE; // Apply damage
                            if (enemy.health <= 0) {
                                enemies.splice(i, 1);
                                score += (enemy.type === 'advanced') ? 30 : (enemy.type === 'ufo' ? 20 : 10);
                                enemiesRemainingThisLevel--;
                                // Perk drop chance on enemy defeat
                                if (Math.random() < PERK_DROP_CHANCE) {
                                    const randomPerkType = PERK_TYPES[Math.floor(Math.random() * PERK_TYPES.length)];
                                    perks.push(new Perk(enemy.x, enemy.y, randomPerkType));
                                }
                            }
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.05", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            updateScoreboard();
                            // No break here, as beam can hit multiple enemies
                        }
                    }

                    // Spacebeam collision with boss
                    if (currentBoss) {
                        if (currentBoss.x + currentBoss.width / 2 > player.x - 20 &&
                            currentBoss.x - currentBoss.width / 2 < player.x + 20 &&
                            currentBoss.y + currentBoss.height / 2 > 0 &&
                            currentBoss.y - currentBoss.height / 2 < player.y) {

                            currentBoss.health -= SPACEBEAM_DAMAGE;
                            if (currentBoss.health <= 0) {
                                score += (currentBoss.type.startsWith('level_')) ? (100 + (currentLevel - 1) * 50) : 50;
                                updateScoreboard();
                                showLevelCompleteScreen(timestamp); // Trigger animation
                                return; // Exit gameLoop to start animation
                            }
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.05", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            currentBoss.updateHealthBar();
                        }
                    }
                }
                // --- End Spacebeam ---


                // Update and draw player bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.update();
                    bullet.draw();
                    if (bullet.y < 0) {
                        bullets.splice(i, 1);
                    }
                }

                // Update and draw enemy bullets
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const eBullet = enemyBullets[i];
                    eBullet.update();
                    eBullet.draw();

                    // Check for enemy bullet collision with player
                    if (!isPlayerInvincible) { // Only take damage if not invincible
                        if (
                            eBullet.x + eBullet.radius > player.x - player.width / 2 &&
                            eBullet.x - eBullet.radius < player.x + player.width / 2 &&
                            eBullet.y + eBullet.radius > player.y - player.height / 2 &&
                            eBullet.y - eBullet.radius < player.y + player.height / 2
                        ) {
                            enemyBullets.splice(i, 1); // Remove bullet
                            lives -= eBullet.damage; // Player takes damage
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.2", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            updateScoreboard();
                            if (lives <= 0) {
                                endGame();
                                return;
                            }
                        }
                    }

                    if (eBullet.y > canvas.height) {
                        enemyBullets.splice(i, 1);
                    }
                }

                // Update and draw UFO beams
                for (let i = ufoBeamsActive.length - 1; i >= 0; i--) {
                    const ufoBeam = ufoBeamsActive[i];
                    const beamStatus = ufoBeam.update(timestamp); // Get current status
                    
                    if (beamStatus === 'inactive') {
                        ufoBeamsActive.splice(i, 1); // Remove inactive beams
                        continue;
                    }
                    ufoBeam.draw(timestamp); // Pass timestamp to draw for charging animation

                    // Only check collision if beam is active (after charge time)
                    if (beamStatus === 'active' && !isPlayerInvincible) {
                        if (
                            player.x + player.width / 2 > ufoBeam.x - ufoBeam.width / 2 &&
                            player.x - ufoBeam.width / 2 < ufoBeam.x + ufoBeam.width / 2 &&
                            player.y + player.height / 2 > ufoBeam.y &&
                            player.y - ufoBeam.height / 2 < ufoBeam.y + ufoBeam.height
                        ) {
                            lives -= ufoBeam.damage; // Player takes damage
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.2", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            updateScoreboard();
                            // ufoBeamsActive.splice(i, 1); // Do not remove beam after hit, it persists for its duration
                            if (lives <= 0) {
                                endGame();
                                return;
                            }
                        }
                    }
                }

                // Update and draw Perks, handle collisions
                for (let i = perks.length - 1; i >= 0; i--) {
                    const perk = perks[i];
                    perk.update();
                    perk.draw();

                    // Check for player-perk collision
                    if (
                        player.x + player.width / 2 > perk.x - perk.radius &&
                        player.x - player.width / 2 < perk.x + perk.radius &&
                        player.y + player.height / 2 > perk.y - perk.radius &&
                        player.y - player.height / 2 < perk.y + perk.radius
                    ) {
                        // Apply perk effect
                        if (collectPerkSound.loaded) {
                            collectPerkSound.start(Tone.now() + 0.001);
                        }
                        if (perk.type === 'heart') {
                            lives = Math.min(lives + 1, maxLives);
                            updateScoreboard();
                        } else if (perk.type === 'speedBoost') {
                            playerTempSpeedMultiplier = 1.5; // 50% speed increase
                            speedBoostEndTime = timestamp + PERK_DURATION;
                            console.log("Speed Boost collected!");
                        } else if (perk.type === 'fireRateBoost') {
                            playerTempFireRateMultiplier = 1.5; // 50% fire rate increase
                            fireRateBoostEndTime = timestamp + PERK_DURATION;
                            console.log("Fire Rate Boost collected!");
                        }
                        perks.splice(i, 1); // Remove collected perk
                    } else if (perk.y > canvas.height + perk.radius) {
                        perks.splice(i, 1); // Remove perk if off-screen
                    }
                }


                // Spawn enemies or boss
                if (!currentBoss) { // Only spawn regular enemies if no boss is active
                    spawnEnemy(timestamp);

                    // Check if all regular enemies for the level are spawned and defeated
                    if (enemiesSpawnedThisLevel >= enemiesToSpawnThisLevel && enemies.length === 0) {
                        // Time to spawn a boss!
                        let bossType = null;
                        if (currentLevel === 1) bossType = 'level_1_boss';
                        else if (currentLevel === 2) bossType = 'level_2_boss';
                        else if (currentLevel === 3) bossType = 'level_3_boss';
                        else if (currentLevel === 4) bossType = 'level_4_boss';
                        else if (currentLevel === 5) bossType = 'level_5_boss';
                        else if (currentLevel === 6) bossType = 'level_6_boss';
                        else if (currentLevel === 7) bossType = 'level_7_boss';
                        // Add more levels here if needed

                        if (bossType) {
                            currentBoss = new Boss(bossType);
                        } else {
                            // For levels beyond defined bosses, proceed to level complete screen
                            showLevelCompleteScreen(timestamp); // Trigger animation
                            return;
                        }
                    }
                }


                // Update and draw enemies, handle collisions
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    enemy.update(timestamp); // Pass timestamp for UFO beam
                    enemy.draw();

                    // Check for player bullet-enemy collision
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const bullet = bullets[j];
                        // Simple rectangular collision detection
                        if (
                            bullet.x + bullet.radius > enemy.x - enemy.width / 2 &&
                            bullet.x - bullet.radius < enemy.x + enemy.width / 2 &&
                            bullet.y + bullet.radius > enemy.y - enemy.height / 2 &&
                            bullet.y - bullet.radius < enemy.y + enemy.height / 2
                        ) {
                            enemy.health -= bullet.damage; // Reduce enemy health
                            bullets.splice(j, 1); // Remove player bullet
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.05", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }

                            if (enemy.health <= 0) {
                                enemies.splice(i, 1); // Remove enemy if health <= 0
                                score += (enemy.type === 'advanced') ? 30 : (enemy.type === 'ufo' ? 20 : 10); // Points for different types
                                enemiesRemainingThisLevel--; // Decrement remaining enemies
                                // Perk drop chance on enemy defeat
                                if (Math.random() < PERK_DROP_CHANCE) {
                                    const randomPerkType = PERK_TYPES[Math.floor(Math.random() * PERK_TYPES.length)];
                                    perks.push(new Perk(enemy.x, enemy.y, randomPerkType));
                                }
                            }
                            updateScoreboard();
                            break; // Only one bullet can hit an enemy
                        }
                    }

                    // Check for enemy-player collision
                    if (!isPlayerInvincible) { // Only take damage if not invincible
                        if (
                            enemy.y + enemy.height / 2 > player.y - player.height / 2 &&
                            enemy.y - enemy.height / 2 < player.y + player.height / 2 &&
                            enemy.x + enemy.width / 2 > player.x - player.width / 2 &&
                            enemy.x - player.width / 2 < player.x + player.width / 2
                        ) {
                            enemies.splice(i, 1);
                            lives -= 1;
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.2", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            updateScoreboard();
                            if (lives <= 0) {
                                endGame();
                                return;
                            }
                        }
                    }

                    // Remove enemies that go off screen
                    if (enemy.y > canvas.height) {
                        enemies.splice(i, 1);
                        enemiesRemainingThisLevel--; // Decrement remaining enemies
                    }
                }

                // Boss update and draw logic
                if (currentBoss) {
                    currentBoss.update(timestamp);
                    currentBoss.draw();
                    currentBoss.updateHealthBar(); // Update boss health bar UI

                    // Check for player bullet-boss collision
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const bullet = bullets[j];
                        // Simple rectangular collision for boss
                        if (
                            bullet.x + bullet.radius > currentBoss.x - currentBoss.width / 2 &&
                            bullet.x - currentBoss.width / 2 < currentBoss.x + currentBoss.width / 2 &&
                            bullet.y + bullet.radius > currentBoss.y - currentBoss.height / 2 &&
                            bullet.y - currentBoss.height / 2 < currentBoss.y + currentBoss.height / 2
                        ) {
                            currentBoss.health -= bullet.damage;
                            bullets.splice(j, 1); // Remove player bullet
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.05", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }

                            if (currentBoss.health <= 0) {
                                score += (currentBoss.type.startsWith('level_')) ? (100 + (currentLevel - 1) * 50) : 50; // Dynamic points for defeating boss
                                updateScoreboard();
                                showLevelCompleteScreen(timestamp); // Trigger animation
                                return;
                            }
                            currentBoss.updateHealthBar(); // Update health bar after hit
                        }
                    }

                    // Check for boss-player collision (if boss can collide with player)
                    if (!isPlayerInvincible) { // Only take damage if not invincible
                        if (
                            currentBoss.y + currentBoss.height / 2 > player.y - player.height / 2 &&
                            currentBoss.y - currentBoss.height / 2 < player.y + player.height / 2 &&
                            currentBoss.x + currentBoss.width / 2 > player.x - player.width / 2 &&
                            currentBoss.x - player.width / 2 < player.x + player.width / 2
                        ) {
                            // Boss collision with player: remove boss and damage player
                            currentBoss.health = 0; // Boss is defeated on collision
                            lives -= 1; // Player takes damage
                            if (performance.now() - lastHitSoundPlayTime > hitSoundDebounceTime) { // Use performance.now() for debounce
                                hitSynth.triggerAttackRelease("0.2", Tone.now() + 0.001); // Add offset
                                lastHitSoundPlayTime = performance.now();
                            }
                            updateScoreboard();
                            showLevelCompleteScreen(timestamp); // Trigger animation
                            return; // Exit gameLoop to start animation
                        }
                    }
                }

                // Update perk indicators
                updatePerkIndicators(timestamp);

            } else if (gameState === 'levelCompleteAnimation') {
                const elapsedTime = timestamp - animationStartTime;
                const zoomDuration = 2000; // 2 seconds for zoom out

                // Animate player ship zooming upwards
                player.y -= player.speed * 2;
                player.draw(); // Draw player during animation

                // Draw "Level Complete!" text fading in/out during animation
                if (elapsedTime < zoomDuration) {
                    ctx.save();
                    ctx.font = "bold 4em 'Inter', sans-serif";
                    ctx.textAlign = "center";
                    ctx.fillStyle = `rgba(0, 255, 0, ${Math.min(1, elapsedTime / 1000)})`; // Fade in over 1 second
                    ctx.shadowColor = 'rgba(0, 255, 0, 1)';
                    ctx.shadowBlur = 20;
                    ctx.fillText("LEVEL COMPLETE!", canvas.width / 2, canvas.height / 2);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }

                if (player.y + player.height / 2 < 0) { // If player is off-screen
                    // Transition to actual level complete screen
                    hideAllScreens();
                    currentLevelDisplay.innerText = currentLevel;
                    levelCompleteScreen.style.display = "flex";
                    gameState = 'levelCompleteScreenDisplayed'; // New state to prevent re-triggering
                }
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Initial setup
        updateScoreboard();

        // Start button event listener
        startButton.addEventListener("click", async () => {
            // Ensure audio context is started on user gesture
            await Tone.start();
            console.log('Audio context started');
            resetGame();
            // gameState is set to 'playing' in resetGame()
        });

        // Level Complete Screen buttons
        goToShopButton.addEventListener("click", () => {
            showShopScreen();
        });

        continueGameButton.addEventListener("click", () => {
            startNextLevel();
        });

        // Shop Screen button
        exitShopButton.addEventListener("click", () => {
            startNextLevel();
        });

        // Restart button event listener (Game Over screen)
        restartButton.addEventListener("click", async () => {
            // Ensure audio context is started on user gesture
            await Tone.start();
            console.log('Audio context started on restart');
            resetGame();
            // gameState is set to 'playing' in resetGame()
        });

        // Start the game loop only when the window is loaded and game starts
        window.onload = async function() {
            // Pre-load all Tone.js audio buffers
            await Tone.loaded();
            console.log("All Tone.js audio buffers loaded!");
            // Enable the start button once audio is loaded
            startButton.disabled = false;
            startButton.innerText = "Start Game";
            // Start the initial game loop for the start screen (starfield)
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        // Initially disable start button until audio is loaded
        startButton.disabled = true;
        startButton.innerText = "Loading Audio...";
    </script>
</body>
</html>
